/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code {:
    // Connect this parser to a scanner!
    scanner s;
    Parser(scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
init with {: s.init(); :};
scan with {: return s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal	boolean,
		break,
		class,
		double,
		else,
		extends,
		for,
		if,
		implements,
		int,
		interface,
		newarray,
		println,
		readln,
		return,
		string,
		void,
		while,
		plus,
		minus,
		multiplication,
		division,
		mod,
		less,
		lessequal,
		greater,
		greaterequal,
		equal,
		notequal,
		and,
		or,
		not,
		assignop,
		semicolon,
		comma,
		period,
		leftparen,
		rightparen,
		reftbracket,
		rightbracket,
		leftbrace,
		rightbrace,
		intconstant,
		doubleconstant,
		stringconstant,
		booleanconstant,
		id;

/* Non terminals */
non terminal	    Program, 
		    Decl, 
		    VariableDecl, 
		    Variable, 
		    Type,
		    FunctionDecl, 
		    Formals,
		    ClassDecl,
		    idListItem,
		    Field,
		    InterfaceDecl,
		    MultiplePrototype,
		    Prototype,
		    StmtBlock,
		    MultipleVariableDecl,
		    MultipleStmt
		    Stmt,
		    IfStmt,
		    WhileStmt,
		    ForStmt,
		    BreakStmt,
		    ReturnStmt,
		    PrintStmt,
		    ExprListItem,
		    Expr,
		    Lvalue,
		    Call,
		    Actuals,
		    Constant;

/* Precedences */
precedence left assignop;
precedence left or;
precedence left and;
precedence left equal, 
		notequal;
precedence left less, 
		lessequal, 
		greater, 
		greaterequal;
precedence left plus, 
		minus;
precedence left multiplication,
		division,
		mod;
precedence left not;
		/*missing unary minus*/
precedence left leftbrace,
		rightbrace,
		period;

/* The grammar rules */
expr_list ::= expr_list expr:e SEMI         {: System.out.println(e);:}
            | expr:e SEMI                   {: System.out.println(e);:}
;
expr      ::= expr:e1 PLUS  expr:e2         {: RESULT = e1+e2;       :}
             | expr:e1 MINUS expr:e2        {: RESULT = e1-e2;       :}
             | expr:e1 TIMES expr:e2        {: RESULT = e1*e2;       :}
             | MINUS expr:e                 {: RESULT = -e;          :}
  	     %prec UMINUS
       | LPAREN expr:e RPAREN	         {: RESULT = e;           :}
       | NUMBER:n	                     {: RESULT = n;           :}
             ;
