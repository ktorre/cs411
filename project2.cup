/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code {:
    // Connect this parser to a scanner!
    scanner s;
    Parser(scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
init with {: s.init(); :};
scan with {: return s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal	boolean,
		break,
		class,
		double,
		else,
		extends,
		for,
		if,
		implements,
		int,
		interface,
		newarray,
		println,
		readln,
		return,
		string,
		void,
		while,
		plus,
		minus,
		multiplication,
		division,
		mod,
		less,
		lessequal,
		greater,
		greaterequal,
		equal,
		notequal,
		and,
		or,
		not,
		assignop,
		semicolon,
		comma,
		period,
		leftparen,
		rightparen,
		reftbracket,
		rightbracket,
		leftbrace,
		rightbrace,
		intconstant,
		doubleconstant,
		stringconstant,
		booleanconstant,
		id;

/* Non terminals */
non terminal	    Program, 
		    Decl, 
		    VariableDecl, 
		    Variable, 
		    Type,
		    FunctionDecl, 
		    Formals,
		    ClassDecl,
		    idListItem,
		    Field,
		    InterfaceDecl,
		    MultiplePrototype,
		    Prototype,
		    StmtBlock,
		    MultipleVariableDecl,
		    MultipleStmt
		    Stmt,
		    IfStmt,
		    WhileStmt,
		    ForStmt,
		    BreakStmt,
		    ReturnStmt,
		    PrintStmt,
		    ExprListItem,
		    Expr,
		    Lvalue,
		    Call,
		    Actuals,
		    Constant;

/* Precedences */
precedence left assignop;
precedence left or;
precedence left and;
precedence left equal, 
		notequal;
precedence left less, 
		lessequal, 
		greater, 
		greaterequal;
precedence left plus, 
		minus;
precedence left multiplication,
		division,
		mod;
precedence left not;
		/*missing unary minus*/
precedence left leftbrace,
		rightbrace,
		period;

/* The grammar rules */
Program ::= Decl
;
Decl ::= VariableDecl Decl
       | FunctionDecl Decl
       | ClassDecl Decl
       | InterfaceDecl Decl
       | VariableDecl
       | FunctionDecl
       | ClassDecl
       | InterfaceDecl
;
VariableDecl ::= Variable semicolon
;
Variable ::= Type id
;
Type ::= int
       | double
       | boolean
       | string
       | Type leftbracket rightbracket
       | id
;
FunctionDecl ::= Type id leftparen Formals rightparen StmtBlock
	       | void id leftparen Formals rightparen StmtBlock
	       | Type id leftparen rightparen StmtBlock
	       | void id leftparen rightparen StmtBlock
;
Formals ::= Variable
	  | Variable comma Formals
;
ClassDecl ::= class id leftbrace Field rightbrace
	    | class id extends id leftbrace Field rightbrace
	    | class id implements idListItem leftbrace Field rightbrace
	    | class id extends id implements idListItem leftbrace Field rightbrace
	    | class id leftbrace rightbrace
	    | class id extends id leftbrace rightbrace
	    | class id implements idListItem leftbrace rightbrace
	    | class id extends id implements idListItem leftbrace rightbrace
;
idListItem ::= id
	     | id comma idListItem
;
Field ::= VariableDecl Field
	| FunctionDecl Field
	| VariableDecl
	| FunctionDecl
;
InterfaceDecl ::= interface id leftbrace MultiplePrototype rightbrace
		| interface id leftbrace rightbrace
;
MultiplePrototype ::= Prototype MultiplePrototype
;
Prototype ::= Type id leftparen Formals rightparen semicolon
	    | void id leftparen Formals rightparen semicolon
	    | Type id leftparen rightparen semicolon
	    | void id leftparen rightparen semicolon
;
StmtBlock ::= leftbrace MultipleVariableDecl MultipleStmt rightbrace
	    | leftbrace MultipleVariableDecl rightbrace
	    | leftbrace MultipleStmt rightbrace
	    | leftbrace rightbrace
;
MultipleVariableDecl ::= VariableDecl MultipleVariableDecl
;
MultipleStmt ::= MultipleStmt Stmt
;
Stmt ::= semicolon
       | Expr semicolon
       | IfStmt
       | WhileStmt
       | ForStmt
       | BreakStmt
       | ReturnStmt
       | PrintStmt
       | StmtBlock
;
IfStmt ::= if leftparen Expr rightparen Stmt
	 | if leftparen Expr rightparen else Stmt
;
WhileStmt ::= while leftparen Expr rightparen Stmt
;
ForStmt ::= for leftparen semicolon Expr semicolon rightparen Stmt
	  | for leftparen Expr semicolon Expr semicolon rightparen stmt
	  | for leftparen semicolon Expr semicolon Expr rightparen stmt
	  | for leftparen Expr semicolon Expr semicolon Expr rightparen Stmt
;
BreakStmt ::= break semicolon
;
ReturnStmt ::= return semicolon
	     | return Expr semicolon
;
PrintStmt ::= println leftparen ExprListItem rightparen semicolon
;
ExprListItem ::= Expr comma ExprListItem
	       | Expr
;
Expr ::= Lvalue assignop Expr
       | Constant
       | Lvalue
       | Call
       | leftparen Expr rightparen
       | Expr plus Expr
       | Expr minus Expr
       | Expr multiplication Expr
       | Expr division Expr
       | Expr mod Expr
       | /*unary minus*/ Expr
       | Expr less Expr
       | Expr lessequal Expr
       | Expr greater Expr
       | Expr greaterequal Expr
       | Expr equal Expr
       | Expr notequal Expr
       | Expr and Expr
       | Expr or Expr
       | not Expr
       | readln leftparen rightparen
       | newarray leftparen intconstant comma Type rightparen
;
Lvalue ::= id
	 | Lvalue leftbracket Expr rightbracket
	 | Lvalue period id
;
Call ::= id leftparen Actuals rightparen
       | id period id leftparen Actuals rightparen
       | id leftparen rightparen
       | id period id leftparen rightparen
;
Actuals ::= ExprListItem
;
Constant ::= intconstant
	   | doubleconstant
	   | stringconstant
	   | booleanconstant
;
