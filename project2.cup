/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code {:
    // Connect this parser to a scanner!
    scanner s;
    Parser(scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
init with {: s.init(); :};
scan with {: return s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal	boolean,
		break,
		class,
		double,
		else,
		extends,
		for,
		if,
		implements,
		int,
		interface,
		newarray,
		println,
		readln,
		return,
		string,
		void,
		while,
		plus,
		minus,
		multiplication,
		division,
		mod,
		less,
		lessequal,
		greater,
		greaterequal,
		equal,
		notequal,
		and,
		or,
		not,
		assignop,
		semicolon,
		comma,
		period,
		leftparen,
		rightparen,
		reftbracket,
		rightbracket,
		leftbrace,
		rightbrace,
		intconstant,
		doubleconstant,
		stringconstant,
		booleanconstant,
		id;

/* Non terminals */
non terminal	    Program, 
		    Decl, 
		    VariableDecl, 
		    Variable, 
		    Type,
		    FunctionDecl, 
		    Formals,
		    ClassDecl,
		    idListItem,
		    Field,
		    InterfaceDecl,
		    MultiplePrototype,
		    Prototype,
		    StmtBlock,
		    MultipleVariableDecl,
		    MultipleStmt
		    Stmt,
		    IfStmt,
		    WhileStmt,
		    ForStmt,
		    BreakStmt,
		    ReturnStmt,
		    PrintStmt,
		    ExprListItem,
		    Expr,
		    Lvalue,
		    Call,
		    Actuals,
		    Constant;

/* Precedences */
precedence left assignop;
precedence left or;
precedence left and;
precedence left equal, 
		notequal;
precedence left less, 
		lessequal, 
		greater, 
		greaterequal;
precedence left plus, 
		minus;
precedence left multiplication,
		division,
		mod;
precedence left not;
		/*missing unary minus*/
precedence left leftbrace,
		rightbrace,
		period;

/* The grammar rules */
Program ::= expr_list expr:e SEMI         {: System.out.println(e);:}
            | expr:e SEMI                   {: System.out.println(e);:}
;
expr      ::= expr:e1 PLUS  expr:e2         {: RESULT = e1+e2;       :}
             | expr:e1 MINUS expr:e2        {: RESULT = e1-e2;       :}
             | expr:e1 TIMES expr:e2        {: RESULT = e1*e2;       :}
             | MINUS expr:e                 {: RESULT = -e;          :}
  	     %prec UMINUS
       | LPAREN expr:e RPAREN	         {: RESULT = e;           :}
       | NUMBER:n	                     {: RESULT = n;           :}
;
Program ::= Decl
;
Decl ::= VariableDecl Decl
       | FunctionDecl Decl
       | ClassDecl Decl
       | InterfaceDecl Decl
       | VariableDecl
       | FunctionDecl
       | ClassDecl
       | InterfaceDecl
;
VariableDecl ::= Variable semicolon
;
Variable ::= Type id
;
Type ::= int
       | double
       | boolean
       | string
       | Type leftbracket rightbracket
       | id
;
FunctionDecl ::= Type id leftparen Formals rightparen StmtBlock
	       | void id leftparen Formals rightparen StmtBlock
	       | Type id leftparen rightparen StmtBlock
	       | void id leftparen rightparen StmtBlock
;
Formals ::= Variable
	  | Variable comma Formals
;
ClassDecl ::= class id leftbrace Field rightbrace
	    | class id extends id leftbrace Field rightbrace
	    | class id implements idListItem leftbrace Field rightbrace
	    | class id extends id implements idListItem leftbrace Field rightbrace
;
idListItem ::= id
	     | id comma idListItem
;
Field ::= /*not sure what to do for epsilon*/
	| VariableDecl Field
	| FunctionDecl Field
;
InterfaceDecl ::= interface id leftbrace MultiplePrototype rightbrace
;
MultiplePrototype ::= /*not sure what to do for epsilon*/
		    | Prototype MultiplePrototype
;
Prototype ::= Type id leftparen Formals rightparen semicolon
	    | void id leftparen Formals rightparen semicolon
;
StmtBlock ::= leftbrace MultipleVariableDecl MultipleStmt rightbrace
;
MultipleVariableDecl ::= /*not sure what to do for epsilon*/
		       | VariableDecl MultipleVariableDecl
;
MultipleStmt ::= /*not sure what to do for epsilon*/
	       | MultipleStmt Stmt
;
Stmt ::= semicolon
       | Expr semicolon
       | IfStmt
       | WhileStmt
       | ForStmt
       | BreakStmt
       | ReturnStmt
       | PrintStmt
       | StmtBlock
;
IfStmt ::= if leftparen Expr rightparen Stmt
	 | if leftparen Expr rightparen else Stmt
;
WhileStmt ::= while leftparen Expr rightparen Stmt
;
ForStmt ::= for leftparen semicolon Expr semicolon rightparen Stmt
	  | for leftparen Expr semicolon Expr semicolon rightparen stmt
	  | for leftparen semicolon Expr semicolon Expr rightparen stmt
	  | for leftparen Expr semicolon Expr semicolon Expr rightparen Stmt
;
BreakStmt ::= break semicolon
;
ReturnStmt ::= return semicolon
	     | return Expr semicolon
;
PrintStmt ::= println leftparen ExprListItem rightparen semicolon
;
ExprListItem ::= Expr comma ExprListItem
	       | Expr
;
Expr ::= Lvalue assignop Expr
       | Constant
       | Lvalue
       | Call
       | leftparen Expr rightparen
       | Expr plus Expr
       | Expr minus Expr
       | Expr multiplication Expr
       | Expr division Expr
       | Expr mod Expr
       | /*unary minus*/ Expr
       | Expr less Expr
       | Expr lessequal Expr
       | Expr greater Expr
       | Expr greaterequal Expr
       | Expr equal Expr
       | Expr notequal Expr
       | Expr and Expr
       | Expr or Expr
       | not Expr
       | readln leftparen rightparen
       | newarray leftparen intconstant comma Type rightparen
;
Lvalue ::= id
	 | Lvalue leftbracket Expr rightbracket
	 | Lvalue period id
;
Call ::= id leftparen Actuals rightparen
       | id period id leftparen Actuals rightparen
;
Actuals ::= ExprListItem
	  | /*not sure how to do epsilon*/
;
Constant ::= intconstant
	   | doubleconstant
	   | stringconstant
	   | booleanconstant
;
